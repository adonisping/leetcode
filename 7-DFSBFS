本质是暴力破解：

全局缓存（记忆化搜索） + 剪枝   

递归怎么转化为通用的迭代问题：  
1.用栈来模拟递归，子问题进行反向压栈（因为递归时程序可以按照代码分解除一些列子问题，用迭代要将子问题反向压栈）
2.压栈的数据既为调用子问题的参数，回溯很难处理，需要具体问题具体分析

代码框架：   
将原来问题压入栈内  
   
while 栈不为空：
    取出栈顶元素
    if 满足结束条件：
       记录搜索结果
    分离出子问题，反向压入栈内

类似于BFS
    
133.Clone Graph    
Tree树的copy

301. Remove Invalid Parentheses  
followup: 如果只返回要移除的个数怎么办

329. Longest Increasing Path in a Matrix    
记忆化搜索

332. Reconstruct Itinerary

339. Nested List Weight Sum

364	Nested List Weight Sum II

394. Decode String

417  Pacific Atlantic Water Flow

439	Ternary Expression Parser 

472. Concatenated Words

473. Matchsticks to Square

488. Zuma Game

490	The Maze

491. Increasing Subsequences

494. Target Sum

514. Freedom Trail

529. Minesweeper  
怎么随机生成，第一下永远点不中

531	Lonely Pixel I 

533	Lonely Pixel II 

546. Remove Boxes

————————————————————————

10. Regular Expression Matching

44. Wildcard Matching

22. Generate Parentheses

37. Sudoku Solver

51. N-Queens

52. N-Queens II

89. Gray Code

93. Restore IP Addresses

*290.Word Pattern  

291.Word Pattern II

294.	Flip Game II

320	Generalized Abbreviation

351	Android Unlock Patterns

401. Binary Watch

411	Minimum Unique Word Abbreviation

425	Word Squares

526. Beautiful Arrangement

————————————————————————————————————————————————————————————————————————————————
317	Shortest Distance from All Buildings

286	Walls and Gates
